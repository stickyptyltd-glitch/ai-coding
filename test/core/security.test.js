import { describe, it, beforeEach } from 'node:test';\nimport assert from 'node:assert/strict';\nimport { createTestSuite, TestData } from '../../src/testing/test-framework.js';\nimport { SecurityMiddleware } from '../../src/middleware/security.js';\n\n// Test security middleware\ndescribe('Security Middleware Tests', () => {\n  let mockReq, mockRes, nextCalled;\n\n  beforeEach(() => {\n    mockReq = {\n      body: {},\n      query: {},\n      params: {},\n      ip: '127.0.0.1',\n      method: 'GET',\n      url: '/test',\n      get: (header) => header === 'User-Agent' ? 'Test-Agent/1.0' : null\n    };\n    \n    mockRes = {\n      statusCode: 200,\n      status: function(code) {\n        this.statusCode = code;\n        return this;\n      },\n      json: function(data) {\n        this.body = data;\n        return this;\n      }\n    };\n    \n    nextCalled = false;\n  });\n\n  describe('Input Sanitization', () => {\n    it('should sanitize HTML in request body', async () => {\n      const middleware = SecurityMiddleware.sanitizeInput();\n      \n      mockReq.body = {\n        message: '<script>alert(\"xss\")</script>Hello World',\n        title: 'Clean title'\n      };\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, true);\n      assert.strictEqual(mockReq.body.message, 'Hello World');\n      assert.strictEqual(mockReq.body.title, 'Clean title');\n    });\n\n    it('should sanitize query parameters', async () => {\n      const middleware = SecurityMiddleware.sanitizeInput();\n      \n      mockReq.query = {\n        search: '<img src=x onerror=alert(1)>test',\n        page: '1'\n      };\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, true);\n      assert.strictEqual(mockReq.query.search, 'test');\n      assert.strictEqual(mockReq.query.page, '1');\n    });\n\n    it('should reject overly long input', async () => {\n      const middleware = SecurityMiddleware.sanitizeInput({ maxLength: 10 });\n      \n      mockReq.body = {\n        message: 'This is a very long message that exceeds the limit'\n      };\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, false);\n      assert.strictEqual(mockRes.statusCode, 400);\n      assert.strictEqual(mockRes.body.error, 'Invalid input');\n    });\n\n    it('should detect malicious patterns', async () => {\n      const middleware = SecurityMiddleware.sanitizeInput();\n      \n      const maliciousInputs = [\n        'javascript:alert(1)',\n        'vbscript:msgbox(1)',\n        'data:text/html,<script>alert(1)</script>',\n        'onmouseover=alert(1)',\n        '${7*7}', // Template injection\n        '{{7*7}}', // Template injection\n        '<?php echo \"test\"; ?>'\n      ];\n\n      for (const maliciousInput of maliciousInputs) {\n        mockReq.body = { input: maliciousInput };\n        nextCalled = false;\n        mockRes.statusCode = 200;\n\n        await new Promise((resolve) => {\n          middleware(mockReq, mockRes, () => {\n            nextCalled = true;\n            resolve();\n          });\n        });\n\n        assert.strictEqual(nextCalled, false, `Should reject: ${maliciousInput}`);\n        assert.strictEqual(mockRes.statusCode, 400);\n      }\n    });\n\n    it('should allow safe HTML when configured', async () => {\n      const middleware = SecurityMiddleware.sanitizeInput({\n        allowedTags: ['b', 'i', 'em'],\n        allowedAttributes: { b: ['class'], i: ['class'], em: ['class'] }\n      });\n      \n      mockReq.body = {\n        message: '<b>Bold</b> and <i>italic</i> text with <script>evil</script>'\n      };\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, true);\n      assert.strictEqual(mockReq.body.message.includes('<b>Bold</b>'), true);\n      assert.strictEqual(mockReq.body.message.includes('<i>italic</i>'), true);\n      assert.strictEqual(mockReq.body.message.includes('script'), false);\n    });\n  });\n\n  describe('File Upload Security', () => {\n    it('should validate file types', async () => {\n      const middleware = SecurityMiddleware.fileUploadSecurity({\n        allowedMimeTypes: ['image/jpeg', 'image/png']\n      });\n      \n      mockReq.files = [{\n        originalname: 'test.jpg',\n        mimetype: 'image/jpeg',\n        size: 1024 * 1024 // 1MB\n      }];\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, true);\n    });\n\n    it('should reject invalid file types', async () => {\n      const middleware = SecurityMiddleware.fileUploadSecurity({\n        allowedMimeTypes: ['image/jpeg', 'image/png']\n      });\n      \n      mockReq.files = [{\n        originalname: 'malware.exe',\n        mimetype: 'application/octet-stream',\n        size: 1024\n      }];\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, false);\n      assert.strictEqual(mockRes.statusCode, 400);\n    });\n\n    it('should reject files that are too large', async () => {\n      const middleware = SecurityMiddleware.fileUploadSecurity({\n        maxFileSize: 1024 * 1024 // 1MB\n      });\n      \n      mockReq.files = [{\n        originalname: 'large.jpg',\n        mimetype: 'image/jpeg',\n        size: 5 * 1024 * 1024 // 5MB\n      }];\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, false);\n      assert.strictEqual(mockRes.statusCode, 400);\n    });\n\n    it('should reject too many files', async () => {\n      const middleware = SecurityMiddleware.fileUploadSecurity({\n        maxFiles: 2\n      });\n      \n      mockReq.files = [\n        { originalname: 'file1.jpg', mimetype: 'image/jpeg', size: 1024 },\n        { originalname: 'file2.jpg', mimetype: 'image/jpeg', size: 1024 },\n        { originalname: 'file3.jpg', mimetype: 'image/jpeg', size: 1024 }\n      ];\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, false);\n      assert.strictEqual(mockRes.statusCode, 400);\n    });\n\n    it('should detect file extension mismatch', async () => {\n      const middleware = SecurityMiddleware.fileUploadSecurity();\n      \n      mockReq.files = [{\n        originalname: 'image.jpg', // Claims to be JPEG\n        mimetype: 'image/png',     // But is actually PNG\n        size: 1024\n      }];\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      assert.strictEqual(nextCalled, false);\n      assert.strictEqual(mockRes.statusCode, 400);\n      assert.strictEqual(mockRes.body.message.includes('extension'), true);\n    });\n  });\n\n  describe('Validation Rules', () => {\n    it('should validate email format', () => {\n      const rules = SecurityMiddleware.validationRules();\n      assert.strictEqual(typeof rules.email, 'object');\n    });\n\n    it('should validate password strength', () => {\n      const rules = SecurityMiddleware.validationRules();\n      assert.strictEqual(typeof rules.password, 'object');\n    });\n\n    it('should validate username format', () => {\n      const rules = SecurityMiddleware.validationRules();\n      assert.strictEqual(typeof rules.username, 'object');\n    });\n\n    it('should validate UUID format', () => {\n      const rules = SecurityMiddleware.validationRules();\n      assert.strictEqual(typeof rules.id, 'object');\n    });\n  });\n});\n\n// Test malicious pattern detection\ndescribe('Malicious Pattern Detection', () => {\n  const testPatterns = [\n    { input: 'javascript:alert(1)', shouldFail: true },\n    { input: 'vbscript:msgbox(1)', shouldFail: true },\n    { input: 'data:text/html,<script>', shouldFail: true },\n    { input: 'onmouseover=\"alert(1)\"', shouldFail: true },\n    { input: '${process.env.SECRET}', shouldFail: true },\n    { input: '{{constructor.constructor(\"alert(1)\")()}}', shouldFail: true },\n    { input: '<?php system(\"ls\"); ?>', shouldFail: true },\n    { input: 'Hello World', shouldFail: false },\n    { input: 'user@example.com', shouldFail: false },\n    { input: '<p>Safe HTML content</p>', shouldFail: false }\n  ];\n\n  testPatterns.forEach(({ input, shouldFail }) => {\n    it(`should ${shouldFail ? 'reject' : 'accept'}: ${input}`, async () => {\n      const middleware = SecurityMiddleware.sanitizeInput();\n      \n      const mockReq = { body: { test: input }, query: {}, params: {} };\n      const mockRes = {\n        statusCode: 200,\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) { this.body = data; return this; }\n      };\n      \n      let nextCalled = false;\n\n      await new Promise((resolve) => {\n        middleware(mockReq, mockRes, () => {\n          nextCalled = true;\n          resolve();\n        });\n      });\n\n      if (shouldFail) {\n        assert.strictEqual(nextCalled, false, `Should reject malicious input: ${input}`);\n        assert.strictEqual(mockRes.statusCode, 400);\n      } else {\n        assert.strictEqual(nextCalled, true, `Should accept safe input: ${input}`);\n      }\n    });\n  });\n});