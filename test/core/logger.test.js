import { describe, it, before, after, beforeEach } from 'node:test';\nimport assert from 'node:assert/strict';\nimport { createTestSuite, TestData } from '../../src/testing/test-framework.js';\nimport { Logger, createLogger, correlationMiddleware, requestLoggingMiddleware } from '../../src/logger.js';\nimport fs from 'fs/promises';\nimport path from 'path';\n\n// Test logger functionality\ndescribe('Logger System Tests', () => {\n  let testLogDir;\n  let logger;\n\n  before(async () => {\n    testLogDir = path.join(process.cwd(), 'test-logs');\n    await fs.mkdir(testLogDir, { recursive: true });\n  });\n\n  after(async () => {\n    try {\n      await fs.rm(testLogDir, { recursive: true, force: true });\n    } catch (error) {\n      // Ignore cleanup errors\n    }\n  });\n\n  beforeEach(() => {\n    logger = new Logger('TEST', {\n      enableFileLogging: true,\n      logDirectory: testLogDir\n    });\n  });\n\n  it('should create logger with default configuration', () => {\n    const defaultLogger = createLogger('DEFAULT');\n    assert.strictEqual(defaultLogger.name, 'DEFAULT');\n    assert.strictEqual(defaultLogger.level, 'info');\n  });\n\n  it('should generate and set correlation ID', () => {\n    const correlationId = logger.setCorrelationId();\n    assert.strictEqual(typeof correlationId, 'string');\n    assert.strictEqual(correlationId.length, 36); // UUID length\n    assert.strictEqual(logger.correlationId, correlationId);\n  });\n\n  it('should accept custom correlation ID', () => {\n    const customId = 'custom-correlation-id';\n    logger.setCorrelationId(customId);\n    assert.strictEqual(logger.correlationId, customId);\n  });\n\n  it('should manage metadata correctly', () => {\n    const metadata = { userId: '123', action: 'test' };\n    logger.setMetadata(metadata);\n    assert.deepStrictEqual(logger.metadata, metadata);\n\n    const additionalMetadata = { requestId: 'req-456' };\n    logger.setMetadata(additionalMetadata);\n    assert.deepStrictEqual(logger.metadata, { ...metadata, ...additionalMetadata });\n\n    logger.clearMetadata();\n    assert.deepStrictEqual(logger.metadata, {});\n  });\n\n  it('should respect log levels', () => {\n    const debugLogger = new Logger('DEBUG', { enableFileLogging: false });\n    debugLogger.level = 'debug';\n    assert.strictEqual(debugLogger.shouldLog('debug'), true);\n    assert.strictEqual(debugLogger.shouldLog('info'), true);\n    assert.strictEqual(debugLogger.shouldLog('warn'), true);\n    assert.strictEqual(debugLogger.shouldLog('error'), true);\n\n    const errorLogger = new Logger('ERROR', { enableFileLogging: false });\n    errorLogger.level = 'error';\n    assert.strictEqual(errorLogger.shouldLog('debug'), false);\n    assert.strictEqual(errorLogger.shouldLog('info'), false);\n    assert.strictEqual(errorLogger.shouldLog('warn'), false);\n    assert.strictEqual(errorLogger.shouldLog('error'), true);\n    assert.strictEqual(errorLogger.shouldLog('security'), true); // Security always logs\n  });\n\n  it('should log to file in production mode', async () => {\n    const testMessage = 'Test log message';\n    const testData = { testKey: 'testValue' };\n    \n    logger.info(testMessage, testData);\n    \n    // Allow some time for file writing\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const logFiles = await fs.readdir(testLogDir);\n    assert.strictEqual(logFiles.length > 0, true, 'Should create log files');\n    \n    const logContent = await fs.readFile(path.join(testLogDir, logFiles[0]), 'utf-8');\n    assert.strictEqual(logContent.includes(testMessage), true, 'Log should contain message');\n    assert.strictEqual(logContent.includes('testKey'), true, 'Log should contain data');\n  });\n\n  it('should separate error and security logs', async () => {\n    const testError = new Error('Test error');\n    const securityEvent = 'UNAUTHORIZED_ACCESS';\n    \n    logger.error('Error occurred', testError);\n    logger.security(securityEvent, { ip: '192.168.1.1' });\n    \n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const logFiles = await fs.readdir(testLogDir);\n    const errorLogExists = logFiles.some(file => file.includes('error-'));\n    const securityLogExists = logFiles.some(file => file.includes('security-'));\n    \n    assert.strictEqual(errorLogExists, true, 'Should create error log file');\n    assert.strictEqual(securityLogExists, true, 'Should create security log file');\n  });\n\n  it('should log performance metrics', async () => {\n    const operation = 'test-operation';\n    const duration = 150;\n    const data = { itemsProcessed: 100 };\n    \n    logger.performance(operation, duration, data);\n    \n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const logFiles = await fs.readdir(testLogDir);\n    const logContent = await fs.readFile(path.join(testLogDir, logFiles[0]), 'utf-8');\n    \n    assert.strictEqual(logContent.includes(operation), true);\n    assert.strictEqual(logContent.includes('150ms'), true);\n    assert.strictEqual(logContent.includes('itemsProcessed'), true);\n  });\n});\n\n// Test correlation middleware\ndescribe('Correlation Middleware Tests', () => {\n  it('should add correlation ID to request', async () => {\n    const mockReq = {\n      headers: {},\n      method: 'GET',\n      url: '/test',\n      ip: '127.0.0.1',\n      connection: { remoteAddress: '127.0.0.1' }\n    };\n    const mockRes = {\n      setHeader: (key, value) => {\n        mockRes.headers = mockRes.headers || {};\n        mockRes.headers[key] = value;\n      },\n      headers: {}\n    };\n    let nextCalled = false;\n    const mockNext = () => { nextCalled = true; };\n\n    correlationMiddleware(mockReq, mockRes, mockNext);\n\n    assert.strictEqual(typeof mockReq.correlationId, 'string');\n    assert.strictEqual(mockReq.correlationId.length, 36);\n    assert.strictEqual(mockRes.headers['x-correlation-id'], mockReq.correlationId);\n    assert.strictEqual(nextCalled, true);\n    assert.strictEqual(mockReq.logger instanceof Logger, true);\n  });\n\n  it('should use provided correlation ID from header', async () => {\n    const providedId = 'provided-correlation-id';\n    const mockReq = {\n      headers: { 'x-correlation-id': providedId },\n      method: 'GET',\n      url: '/test',\n      ip: '127.0.0.1',\n      connection: { remoteAddress: '127.0.0.1' }\n    };\n    const mockRes = {\n      setHeader: (key, value) => {\n        mockRes.headers = mockRes.headers || {};\n        mockRes.headers[key] = value;\n      },\n      headers: {}\n    };\n    const mockNext = () => {};\n\n    correlationMiddleware(mockReq, mockRes, mockNext);\n\n    assert.strictEqual(mockReq.correlationId, providedId);\n    assert.strictEqual(mockRes.headers['x-correlation-id'], providedId);\n  });\n});\n\n// Test request logging middleware\ndescribe('Request Logging Middleware Tests', () => {\n  it('should log request when response finishes', (done) => {\n    const mockReq = {\n      method: 'GET',\n      url: '/api/test',\n      get: (header) => header === 'User-Agent' ? 'Test-Agent' : null,\n      ip: '127.0.0.1',\n      logger: createLogger('REQUEST-TEST', { enableFileLogging: false })\n    };\n    \n    const mockRes = {\n      statusCode: 200,\n      on: (event, callback) => {\n        if (event === 'finish') {\n          // Simulate response finish after 50ms\n          setTimeout(() => {\n            callback();\n            done();\n          }, 50);\n        }\n      }\n    };\n    \n    const mockNext = () => {\n      // Simulate response finishing\n      mockRes.on('finish', () => {});\n    };\n\n    requestLoggingMiddleware(mockReq, mockRes, mockNext);\n  });\n});