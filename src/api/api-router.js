import express from 'express';\nimport { createLogger } from '../logger.js';\nimport { AppError, NotFoundError } from '../errors/error-handler.js';\n\nconst logger = createLogger('API-ROUTER');\n\n// API versioning and routing system\nexport class ApiRouter {\n  constructor() {\n    this.router = express.Router();\n    this.versions = new Map();\n    this.deprecatedVersions = new Set();\n  }\n\n  // Add API version\n  addVersion(version, routes, options = {}) {\n    const {\n      deprecated = false,\n      deprecationDate = null,\n      sunsetDate = null,\n      description = `API version ${version}`\n    } = options;\n\n    if (deprecated) {\n      this.deprecatedVersions.add(version);\n    }\n\n    this.versions.set(version, {\n      version,\n      routes,\n      deprecated,\n      deprecationDate,\n      sunsetDate,\n      description,\n      createdAt: new Date().toISOString()\n    });\n\n    // Mount version-specific routes\n    this.router.use(`/v${version}`, this.versionMiddleware(version), routes);\n    \n    logger.info(`API version v${version} registered`, {\n      deprecated,\n      description,\n      routeCount: this.getRouteCount(routes)\n    });\n  }\n\n  // Version-specific middleware\n  versionMiddleware(version) {\n    return (req, res, next) => {\n      req.apiVersion = version;\n      \n      // Add version info to response headers\n      res.set({\n        'API-Version': version,\n        'X-API-Version': version\n      });\n\n      // Add deprecation warnings for deprecated versions\n      if (this.deprecatedVersions.has(version)) {\n        const versionInfo = this.versions.get(version);\n        res.set({\n          'Deprecation': 'true',\n          'Sunset': versionInfo.sunsetDate || 'TBD',\n          'Warning': `299 - \"API version v${version} is deprecated\"`\n        });\n        \n        logger.warn('Deprecated API version accessed', {\n          version,\n          ip: req.ip,\n          userAgent: req.get('User-Agent'),\n          url: req.url\n        });\n      }\n\n      next();\n    };\n  }\n\n  // Content negotiation middleware\n  contentNegotiation() {\n    return (req, res, next) => {\n      // Default to JSON if no Accept header\n      if (!req.get('Accept')) {\n        req.headers.accept = 'application/json';\n      }\n\n      // Only support JSON for now\n      if (!req.accepts('json')) {\n        throw new AppError('Only JSON responses are supported', 406, 'NOT_ACCEPTABLE');\n      }\n\n      // Set response content type\n      res.type('json');\n      next();\n    };\n  }\n\n  // Get API information\n  getApiInfo() {\n    const versions = Array.from(this.versions.values()).map(v => ({\n      version: v.version,\n      deprecated: v.deprecated,\n      deprecationDate: v.deprecationDate,\n      sunsetDate: v.sunsetDate,\n      description: v.description\n    }));\n\n    return {\n      name: 'Lecheyne AI API',\n      description: 'Multi-agent AI development platform API',\n      versions,\n      currentVersion: this.getCurrentVersion(),\n      supportedVersions: this.getSupportedVersions()\n    };\n  }\n\n  getCurrentVersion() {\n    const versions = Array.from(this.versions.keys())\n      .filter(v => !this.deprecatedVersions.has(v))\n      .sort((a, b) => b - a);\n    return versions[0] || null;\n  }\n\n  getSupportedVersions() {\n    return Array.from(this.versions.keys())\n      .filter(v => !this.deprecatedVersions.has(v))\n      .sort((a, b) => b - a);\n  }\n\n  getRouteCount(routes) {\n    if (!routes || !routes.stack) return 0;\n    return routes.stack.length;\n  }\n\n  // Mount the router\n  getRouter() {\n    // API info endpoint\n    this.router.get('/', (req, res) => {\n      res.json(ApiResponse.success(this.getApiInfo(), {\n        message: 'Lecheyne AI API'\n      }));\n    });\n\n    // Version-specific info\n    this.router.get('/v:version', (req, res) => {\n      const version = req.params.version;\n      const versionInfo = this.versions.get(version);\n      \n      if (!versionInfo) {\n        throw new NotFoundError(`API version v${version}`);\n      }\n      \n      res.json(ApiResponse.success(versionInfo));\n    });\n\n    return this.router;\n  }\n}\n\n// Standardized API response formatter\nexport class ApiResponse {\n  static success(data = null, options = {}) {\n    const {\n      message = 'Success',\n      pagination = null,\n      links = null,\n      meta = null\n    } = options;\n\n    const response = {\n      success: true,\n      message,\n      data,\n      timestamp: new Date().toISOString()\n    };\n\n    if (pagination) {\n      response.pagination = pagination;\n    }\n\n    if (links) {\n      response.links = links;\n    }\n\n    if (meta) {\n      response.meta = meta;\n    }\n\n    return response;\n  }\n\n  static error(message, code = 'ERROR', details = null) {\n    return {\n      success: false,\n      error: {\n        code,\n        message,\n        details,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  static paginated(data, pagination, options = {}) {\n    return this.success(data, {\n      ...options,\n      pagination: {\n        page: pagination.page,\n        limit: pagination.limit,\n        total: pagination.total,\n        totalPages: Math.ceil(pagination.total / pagination.limit),\n        hasNext: pagination.page < Math.ceil(pagination.total / pagination.limit),\n        hasPrev: pagination.page > 1\n      }\n    });\n  }\n\n  static created(data, location = null) {\n    const response = this.success(data, { message: 'Resource created successfully' });\n    \n    if (location) {\n      response.links = {\n        self: location\n      };\n    }\n    \n    return response;\n  }\n\n  static noContent() {\n    return {\n      success: true,\n      message: 'No content',\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// Response formatting middleware\nexport function responseFormatterMiddleware(req, res, next) {\n  // Override res.json to format all responses\n  const originalJson = res.json;\n  \n  res.json = function(data) {\n    // Don't format if already formatted\n    if (data && typeof data === 'object' && 'success' in data) {\n      return originalJson.call(this, data);\n    }\n    \n    // Format successful responses\n    if (res.statusCode >= 200 && res.statusCode < 300) {\n      return originalJson.call(this, ApiResponse.success(data));\n    }\n    \n    return originalJson.call(this, data);\n  };\n\n  // Override res.send for plain text responses\n  const originalSend = res.send;\n  \n  res.send = function(data) {\n    // Only format JSON responses\n    if (res.get('Content-Type') && res.get('Content-Type').includes('application/json')) {\n      return res.json(data);\n    }\n    \n    return originalSend.call(this, data);\n  };\n\n  // Add convenience methods\n  res.success = function(data, options) {\n    return this.json(ApiResponse.success(data, options));\n  };\n\n  res.error = function(message, code, statusCode = 400) {\n    this.status(statusCode);\n    return this.json(ApiResponse.error(message, code));\n  };\n\n  res.paginated = function(data, pagination, options) {\n    return this.json(ApiResponse.paginated(data, pagination, options));\n  };\n\n  res.created = function(data, location) {\n    this.status(201);\n    if (location) {\n      this.location(location);\n    }\n    return this.json(ApiResponse.created(data, location));\n  };\n\n  res.noContent = function() {\n    this.status(204);\n    return this.json(ApiResponse.noContent());\n  };\n\n  next();\n}\n\n// Pagination helper\nexport class PaginationHelper {\n  static paginate(query = {}) {\n    const page = Math.max(1, parseInt(query.page) || 1);\n    const limit = Math.min(100, Math.max(1, parseInt(query.limit) || 20));\n    const offset = (page - 1) * limit;\n\n    return {\n      page,\n      limit,\n      offset,\n      sort: query.sort || 'createdAt',\n      order: query.order === 'asc' ? 'ASC' : 'DESC'\n    };\n  }\n\n  static buildPaginationResponse(data, total, pagination) {\n    return {\n      data,\n      pagination: {\n        page: pagination.page,\n        limit: pagination.limit,\n        total,\n        totalPages: Math.ceil(total / pagination.limit),\n        hasNext: pagination.page < Math.ceil(total / pagination.limit),\n        hasPrev: pagination.page > 1\n      }\n    };\n  }\n}\n\n// HATEOAS links helper\nexport class HateoasHelper {\n  static buildLinks(resource, baseUrl, relations = []) {\n    const links = {\n      self: `${baseUrl}/${resource.id}`\n    };\n\n    relations.forEach(relation => {\n      switch (relation) {\n        case 'edit':\n          links.edit = `${baseUrl}/${resource.id}`;\n          break;\n        case 'delete':\n          links.delete = `${baseUrl}/${resource.id}`;\n          break;\n        case 'parent':\n          if (resource.parentId) {\n            links.parent = `${baseUrl.replace(/\\/[^/]*$/, '')}/${resource.parentId}`;\n          }\n          break;\n        default:\n          if (resource[`${relation}Id`]) {\n            links[relation] = `${baseUrl.replace(/\\/[^/]*$/, `/${relation}s`)}/${resource[`${relation}Id`]}`;\n          }\n      }\n    });\n\n    return links;\n  }\n}\n\nexport default ApiRouter;